# С помощью ключевого слова raise можно создать простой класс ошибки, задать ему текстовое описание и вызвать эту ошибку
# на любом уровне. Если ошибка возникает в функции и не обрабатывается на этом же уровне, она передается выше по стеку
# вызовов. Это напоминает пример с башенкой: исключение поднимается вверх до тех пор, пока его не перехватят или оно не
# приведет к сбою программы и не отобразится в консоли. Таким образом, именно так функционирует raise.

# Зачем нужно использовать raise? Вот основные причины:
# 1) Генерация исключений при некорректных аргументах: если функции передаются неверные аргументы, которые не
# предусмотрены разработчиком, можно использовать raise, чтобы предупредить пользователя о неправильном использовании
# функции или части кода. В этом случае можно поймать неправильные аргументы, сравнить их с ожидаемыми значениями и
# вызвать исключение, передавая его на уровень выше для дальнейшей обработки.
# 2) Невозможность или бессмысленность дальнейшего выполнения кода: когда определенная часть кода достигает состояния,
# в котором его дальнейшее выполнение невозможно или нецелесообразно, можно вызвать исключение, обозначая тем самым
# конец исполнения.
# 3) Ошибки в логике программы: если в коде обнаруживается логическая ошибка, которая не должна была возникнуть при
# корректной работе, можно вызвать собственное исключение. Это помогает выявить проблемы на этапе исполнения и упростить
# их устранение.

# Пример 1
# def greet_person(person_name):
#     if person_name == 'ВоланДеМорт':
#         # Вызов ошибки с аргументом 'Мы не любим тебя ВоланДеМорт'
#         raise Exception('Мы не любим тебя ВоланДеМорт')
#     print(f'Привет {person_name}')
#
#
# greet_person('Ni12ck')
# # greet_person('ВоланДеМорт')  # Exception: Мы не любим тебя ВоланДеМорт

# Пример 2 - raise ошибки, но перед этим она уже была обработана
# try:
#     raise NameError('Привет Там')
# except NameError as exc:
#     print(f'Исключение типа {type(exc)} прошло дальше, его параметры {exc.args}')
#     raise


# Как создать собственный класс ошибок?
# 1) Определение класса: для начала необходимо придумать название класса и наследовать его от класса Exception. Хотя
# можно наследоваться и от других классов, наследование от Exception является удобным выбором, поскольку этот класс
# специально предназначен для работы с исключениями, которые требуется перехватывать.
# 2) Создание продвинутого класса: можно разработать более сложный класс, который будет содержать детальное описание,
# собственные функции, методы и характеристики. Такой подход позволяет вызывать исключение, обрабатывать его и внутри
# самого класса предоставить объяснение произошедшего, какие параметры были задействованы, и что можно сделать для
# предотвращения ошибки или продолжения работы. Например, можно включить внутреннюю функцию, которая подскажет, как
# обойти возникшую ошибку.

# Пример 3
class ProZero(Exception):
    def __init__(self, message, extra_info):
        self.message = message
        self.extra_info = extra_info


def divider(a, b):
    if b == 0:
        raise ProZero('Деление на ноль невозможно', {'a': a, 'b': b})
    return a / b


try:
    result = divider(10, 0)
    print(result)
except ProZero as exc:
    print("Найдена ошибка")
    print(f'Сообщение об ошибке: {exc.message}')
    print(f'Дополнительная информация: {exc.extra_info}')

# print(divider(1, 4))
# print(divider(1, 0)) # ProZero: Деление на ноль невозможно
