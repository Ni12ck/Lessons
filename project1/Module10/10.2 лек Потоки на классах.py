# Работа с потоками на основе классов дает несколько преимуществ:
# 1) Логическая структура: легче организовать код, особенно когда потоку требуется больше данных или сложная логика.
# 2) Инкапсуляция: код потока находится внутри класса, что делает его более организованным и поддерживаемым.
# 3) Расширяемость: в классе можно легко добавлять дополнительные методы и атрибуты для управления потоком, отслеживания
# состояния, обработки ошибок и т.д.

# Создание собственного класса
import threading
import time


# Создадим класс MyThread, наследуемый от класса ‘threading.Thread’. Здесь есть важный момент: обычно при создании
# собственного класса-потока необходимо переопределить метод ‘run()’. Именно в этом методе описывается порядок действий,
# который должен выполнить наш поток. Этот метод автоматически вызывается, когда мы запускаем поток с помощью метода
# ‘start()’. Однако не всегда переопределение метода ‘run()’ может быть достаточно для решения всех задач.
class MyThread(threading.Thread):
    def __init__(self, name, counter, delay):
        # Первый и наиболее распространённый способ — это вызвать конструктор родительского класса через ‘super()’.
        # Этот метод автоматически находит родительский класс и вызывает его конструктор с необходимыми аргументами.
        # В данном примере мы вызываем ‘super().__init__(name=name)’, передавая имя потока через конструктор
        # ‘threading.Thread’.
        # Прямой вызов конструктора родительского класса
        threading.Thread.__init__(self)
        # Если написать ‘self.name = name’, то этого будет недостаточно, потому что у потоков есть свой конструктор и,
        # чтобы все работало правильно, нужно его вызвать.
        self.name = name
        self.counter = counter  # счётчик сколько раз надо вывести время
        self.delay = delay

    def timer(self, name, counter, delay):
        while counter != 0:
            # Задержка
            time.sleep(delay)
            # Красивый вывод времени
            print(f'Поток {name} показывает время {time.ctime(time.time())}\n')
            # Чтобы не повторялось бесконечное количество времени, счётчик будем уменьшать
            counter -= 1

    # Переопределяем метод run и описываем логику потока
    def run(self):
        print(f'Поток {self.name} запущен')
        self.timer(self.name, self.counter, self.delay)
        print(f'Поток {self.name} завершён')


# Создадим два потока
thread1 = MyThread('thread1', 5,1)
thread2 = MyThread('thread2', 3,2)

# Метод start также запускает срабатывание метода run
thread1.start()
thread2.start()
