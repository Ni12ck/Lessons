# Словари
# Словарь позволяет хранить в себе элементы парами - {ключ:значение}
# Словарь телефонная книга, где ключ имя, а значение номер телефона
phone_book = {'Владимир': 89726374837, 'Наташа': 89996451235}
print('Телефонная книга:', phone_book)
# Ключом должен быть нехэшируемый (неизменяемый) объект
# Ключ нельзя менять, а значение можно
# Обращение к элементу, в скобках надо указать ключ
print('Элемент с ключом "Владимир":', phone_book['Владимир'])

# Также можно заменить значение элементов
phone_book['Владимир'] = 89775553311
print('Телефонная книга после изменения одного элемента:', phone_book)

# Также можно добавить новый элемент в словарь подобным образом
# Если обратиться к несуществующему ключу, то словарь создаёт новый
phone_book['Антон'] = 89775550078
print('Телефонная книга после добавления новой записи:', phone_book)

# Также можно удалить элемент в словаре подобным образом
del phone_book['Антон']
print('Телефонная книга после удаления записи:', phone_book)

# Существует метод update, который позволяет обновить несколько пар сразу
# Метод update принимает другой словарь, который нао написать в скобках
phone_book.update({'Андрей': 89557773434, 'Витя': 89110001617})
print('Телефонная книга после обновления:', phone_book)
# Порядок вывода элементов может быть случайным, потому что словари не упорядочены

# Метод .get будет возвращать значение по указанному ключу
print('Номер Наташи:', phone_book.get('Наташа'))
# Метод .get обязательно возвращает значение, если элемента нет, то возвращается None
print('Несуществующий номер:', phone_book.get('Сергей'))
# Можно указать значение по умолчанию, которое будет отображаться, если элемента нет
print('Несуществующий номер:', phone_book.get('Сергей', 'Такого номера нет'))

# Метод .pop вытаскивает из словаря значение, которое можно присвоить переменной, это значение остаётся в памяти
print('Телефонная книга:', phone_book)
Vitya_pop = phone_book.pop('Витя')
print('Телефонная книга после использования pop:', phone_book)
print('Номер Вити:', Vitya_pop)
# Для списков pop работает также, только надо указать [индекс]
list1 = [1, 2, 3, 4, 5]
print('Список list1:', list1)
per_pop = list1.pop(2)
list1.pop(3)
print('Третий элемент из списка list1:', per_pop)
print('Изменённый список list1:', list1)

# Метод .keys позволяет получить коллекцию из ключей в словарике
print('Имена из телефонной книги:', phone_book.keys())

# Метод .values позволяет получить коллекцию из значений в словарике
print('Номера из телефонной книги:', phone_book.values())

# Метод .items позволяет получить коллекцию из пар в словарике
print('Имена с номерами из телефонной книги:', phone_book.items())

# ////////////////////////////////////////////
print()
# ////////////////////////////////////////////

# Множества
# Множества представляют из себя коллекции, хранящие только уникальные значения разных типов
# Например в данном множестве повторяются 1, 2, 3, 4
set_ = {1, 2, 3, 4, 5, 1, 3, 4, 2, 'значение', True, 1.5, (1, 2, 3, 4)}
print('Множесвто set_:', set_)
# Можно сделать множество из списка
list2 = ['А', 'Б', 'В', 'А', 'А', 1, 2, 3, 1, 3, 5, 4]
print('Множество из списка list2:', set(list2))
# Также можно присвоить значение множества переменной
list2 = set(list2)
print('Множество из списка list2:', list2)
# По индексу нельзя обратиться к элементу множества
# Можно удалить элемент из множества
# discard и remove, отличие в том, что discard не будет выдавать ошибку, если элемент не был найден во множестве
print('Удаление из множества list2 элемент "1" с помощью discard:', list2.discard(1))
print('Удаление из множества list2 элемент "2" с помощью remove:', list2.remove(2))
print('Множество из списка list2 после удаления:', list2)
# Также можно вытащить элемент с помощью pop
# Можно добавить элемент с помощью add
list2.add(5)
print('Множество из списка list2 после добавления 5:', list2)