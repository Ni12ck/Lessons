# Генератор-это специальная функция, которую мы сами пишем, создаём, которая возвращает итератор. И с помощью этого
# итератора можно снова пройтись по какой-либо коллекции, прочитать эти данные поэлементно. Когда функция-генератор,
# она не выполняет свое тело сразу, а возвращает объект-генератор (это и логично, она является так же ленивым
# вычислением), итерация по которому будет выполнять тело функции и возвращать значения по мере их генерации.

# Итераторы требуют больше кода, нам для этого приходилось создавать большой класс. Так же они требуют больше понимания
# протокола итератора. Генераторы позволяют создать итератор более простым и удобным способом. Итераторы нужны для
# действительно очень сложных программ или библиотек, их будут писать достаточно редко, а генераторы пишут частенько.
# Потому что они намного проще, они точно так же возвращают итератор.

print('Первый пример, создание простого генератора:')


def func_generator(n):
    i = 0
    while n != i:
        yield i
        i += 1


obj_1 = func_generator(5)
print(f'Выводится сам объект, а не результат выполнения функции: {obj_1}')
print(f'Вывод списка: {list(obj_1)}')
print()

print('Второй пример:')


def fibonacci_v1(n):
    result = []
    a, b = 0, 1
    for i in range(n):
        result.append(a)
        a, b = b, a + b
    return result


def fibonacci_v2(n):
    a, b = 0, 1
    for i in range(n):
        yield a
        a, b = b, a + b


fib_1 = fibonacci_v1(5)
print(f'Вывод результата первой функции: {fib_1}')

fib_2 = fibonacci_v2(5)
print(f'Выводится сам объект, а не результат выполнения функции: {fib_2}')
print(f'Вывод списка второй функции: {list(fib_2)}')
print(f'Второй раз вывести результат второй функции нельзя: {list(fib_2)}')
print(f'Вывод результата первой функции для примера: {fib_1}')
print()

print('Третий пример, можно сделать бесконечный список значений:')


def fibonacci_v3():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b


for value in fibonacci_v3():
    print(value)
    if value > 10 ** 6:
        break

print()

print('Четвёртый пример:')

import time

start = time.time()


def read_large_file(file_path):
    with open(file_path, 'r', encoding='utf-8') as file:
        for line in file:
            yield line.strip()


for line in read_large_file('large_file.txt'):
    print(line)

fin = time.time()
print(f'Время в миллисекундах: {(fin - start) * 1000}')
